/************************************************************/
/*                     IMPORTANTE                           */
/*   Esta aplicacion es parte de los  paquetes bancarios    */
/*   propiedad de COBISCORP.                                */
/*   Su uso no autorizado queda  expresamente  prohibido    */
/*   asi como cualquier alteracion o agregado hecho  por    */
/*   alguno de sus usuarios sin el debido consentimiento    */
/*   por escrito de COBISCORP.                              */
/*   Este programa esta protegido por la ley de derechos    */
/*   de autor y por las y por las convenciones              */
/*   internacionales de  propiedad intelectual. Su uso no   */
/*   autorizado dara  derecho a  COBISCORP para obtener     */
/*   ordenes de  secuestro o retencion y  para perseguir    */
/*   penalmente a los autores de cualquier infraccion.      */
/************************************************************/
/*   This code was generated by CEN-SG.                     */
/*   Changes to this file may cause incorrect behavior      */
/*   and will be lost if the code is regenerated.           */
/************************************************************/

package com.cobis.cloud.sofom.service.oxxo.security;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import cobiscorp.ecobis.commons.dto.MessageTO;
import cobiscorp.ecobis.cts.integration.services.ICTSServiceIntegration;
import cobiscorp.ecobis.cts.integration.services.dto.CTSSessionRequest;

import com.cobis.cloud.sofom.service.oxxo.security.dto.CTSServiceResponseTO;
import com.cobis.cloud.sofom.service.oxxo.utils.OxxoConstants;
import com.cobiscorp.cobis.commons.crypt.ReadAlgn;
import com.cobiscorp.cobis.commons.exceptions.COBISException;
import com.cobiscorp.cobis.commons.log.ILogger;
import com.cobiscorp.cobis.commons.log.LogFactory;

public class COBISSecurityManager {
	private static final ILogger LOGGER = LogFactory.getLogger(COBISSecurityManager.class);

	private static Map<SessionSecurityKey, String> sessionMap = new HashMap<SessionSecurityKey, String>();

	private static boolean lock = false;
	private static String externalUserId = null;
	private static String externalApplicationId = null;
	private static String password = null;


	public static synchronized <T extends CTSServiceResponseTO> boolean initializeSession(ICTSServiceIntegration ctsServiceIntegration, SessionSecurityKey secKey, T response) {
		LOGGER.logDebug("INICIALIZA METODO DE SINCRONIZACION");

		try {
			if (LOGGER.isTraceEnabled()) {
				LOGGER.logTrace("START initializeSession");
			}

			String backendId = secKey.getBackendId();

			LOGGER.logDebug("BACKEND ID: " + backendId);

			if (sessionMap.get(secKey) != null) {
				return true;
			}
			lock = true;

			// if user is sent in header
			if (secKey.getLogin() != null && secKey.getApplicationId() != null) {
				if (LOGGER.isDebugEnabled()) {
					LOGGER.logDebug("Initializing session using header params");
				}

				CTSSessionRequest sessionReq = new CTSSessionRequest();
				sessionReq.setExternalApplicationId(secKey.getApplicationId());
				sessionReq.setExternalUserId(secKey.getLogin());
				sessionReq.setPassword(secKey.getPassword());
				if (backendId != null) {
					sessionReq.setBackEndId(backendId);
				}
				if (LOGGER.isDebugEnabled()) {
					LOGGER.logDebug("externalUserId: " + secKey.getLogin() + ", externalApplicationId: " + secKey.getApplicationId() + ", backendId: " + backendId);
				}
				String wSessionId = ctsServiceIntegration.initializeSession(sessionReq);
				sessionMap.put(secKey, wSessionId);
				if (LOGGER.isTraceEnabled()) {
					LOGGER.logTrace("END initializeSession. sessionId = " + wSessionId);
				}
				return true;
			}
			if (externalUserId == null || externalApplicationId == null) {
				// algn File
				if (LOGGER.isDebugEnabled()) {
					LOGGER.logDebug("Initializing session using Algn file");
					LOGGER.logDebug("Folder: " + System.getProperty("COBIS_HOME_WEB"));
				}
				String algnFile = null;

				algnFile = System.getProperty("COBIS_HOME_WEB") + "/CLIENT_ALGNS/" + OxxoConstants.ALGCON_FILE;
				if (algnFile == null || "".equals(algnFile)) {
					response.setSuccess(false);
					MessageTO errorMessage = new MessageTO();
					errorMessage.setMessage("File doesn't exist : " + algnFile);
					response.setMessages(new MessageTO[] { errorMessage });
					return false;
				}
				File file = new File(algnFile);
				LOGGER.logDebug(file);
				LOGGER.logDebug(!file.exists());

				if (!file.exists()) {
					response.setSuccess(false);
					MessageTO errorMessage = new MessageTO();
					errorMessage.setMessage("File doesn't exist : " + algnFile);
					response.setMessages(new MessageTO[] { errorMessage });
					if (LOGGER.isErrorEnabled()) {
						LOGGER.logError("File doesn't exist : " + algnFile);
					}
					return false;
				}
				ReadAlgn wAlgReader = new ReadAlgn(algnFile);

				LOGGER.logDebug("wAlgReader" + wAlgReader);

				Properties wProperties = wAlgReader.leerParametros();

				LOGGER.logDebug("wProperties" + wProperties);

				externalUserId = wProperties.getProperty("l");
				externalApplicationId = wProperties.getProperty("s");
				password = wProperties.getProperty("p");

				LOGGER.logDebug("externalUserId" + externalUserId);
				LOGGER.logDebug("externalApplicationId" + externalApplicationId);
				LOGGER.logDebug("password" + password);

			}

			CTSSessionRequest sessionReq = new CTSSessionRequest();
			sessionReq.setExternalApplicationId(externalApplicationId);
			sessionReq.setExternalUserId(externalUserId);
			sessionReq.setPassword(password);

			LOGGER.logDebug("sessionReq:" + sessionReq.getExternalApplicationId());
			LOGGER.logDebug("sessionReq:" + sessionReq.getExternalUserId());

			LOGGER.logDebug("BAKEND:" + backendId);

			if (backendId != null) {
				sessionReq.setBackEndId(backendId);
			}
			if (LOGGER.isDebugEnabled()) {
				LOGGER.logDebug("externalUserId: " + externalUserId + ", externalApplicationId: " + externalApplicationId + ", backendId: " + backendId);
			}

			String wSessionId = ctsServiceIntegration.initializeSession(sessionReq);

			LOGGER.logDebug("WSSESSION" + wSessionId);

			secKey.setLogin(externalUserId);
			secKey.setApplicationId(externalApplicationId);

			LOGGER.logDebug("WSKEY" + secKey);

			sessionMap.put(secKey, wSessionId);
			if (LOGGER.isTraceEnabled()) {
				LOGGER.logTrace("END initializeSession. sessionId = " + wSessionId);
			}
			return true;
		} catch (COBISException e) {
			if (LOGGER.isErrorEnabled()) {
				LOGGER.logError(e, e);
			}
			response.setSuccess(false);
			MessageTO errorMessage = new MessageTO();
			errorMessage.setMessage(e.getMessage());
			MessageTO[] messages = { errorMessage };
			response.setMessages(messages);
		} finally {
			lock = false;
		}
		return false;
	}

	public static String getSessionId(SessionSecurityKey secKey) {
		try {
			while (lock)
				Thread.sleep(100);
		} catch (InterruptedException e) {
			if (LOGGER.isErrorEnabled()) {
				LOGGER.logError(e, e);
			}
		}
		return sessionMap.get(secKey);
	}

	public static synchronized void clearSessionId(SessionSecurityKey secKey) {
		// Solo se debe este metodo antes de llamar a initializeSession
		lock = true;
		sessionMap.remove(secKey);
		externalUserId = null;
		externalApplicationId = null;
	}

	public static synchronized void setExternalUserId(String aExternalUserId) {
		externalUserId = aExternalUserId;
	}

	public static synchronized void setExternalApplicationId(String aExternalApplicationId) {
		externalApplicationId = aExternalApplicationId;
	}

}
